package com.letattung.layers;

import java.nio.channels.CancelledKeyException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class CakeBankingServiceImpl implements CakeBankingService{

	private AbstractApplicationContext context;
	
	public CakeBankingServiceImpl() {
		this.context = new ClassPathXmlApplicationContext("applicationContext.xml");
	}
	
	@Override
	public void bakeNewCake(CakeInfo cakeInfo) throws CakeBankingException {
		List<CakeTopping> allToppings = getAvailableToppingEntities();
		List<CakeTopping> matchingToppings = allToppings.stream().filter(t -> t.getName().equals(cakeInfo.cakeToppingInfo.name))
				.collect(Collectors.toList());
		if (matchingToppings.isEmpty()){
			throw new CakeBankingException(String.format("Topping %s is not available",
			          cakeInfo.cakeToppingInfo.name));
		}
		List<CakeLayer> allLayers = getAvailableLayerEntities();
		Set<CakeLayer> foundLayers = new HashSet<>();
		for (CakeLayerInfo info : cakeInfo.cakeLayerInfos){
			Optional<CakeLayer> found = allLayers.stream().filter(layer -> layer.getName().equals(info.name)).findFirst();
			if (!found.isPresent()){
				throw new CakeBakingException(String.format("Layer %s is not available", info.name));
			}else{
				foundLayers.add(found.get());
			}
		}
		CakeToppingDao toppingBean = context.getBean(CakeToppingDao.class);
		CakeTopping topping = toppingBean.findOne(matchingToppings.iterator().next().getId());
		CakeDao cakeBean = context.getBean(CakeDao.class);
		Cake cake = new Cake();
	    cake.setTopping(topping);
	    cake.setLayers(foundLayers);
	    cakeBean.save(cake);
	    topping.setCake(cake);
	    toppingBean.save(topping);
	    CakeLayerDao layerBean = context.getBean(CakeLayerDao.class);
	    for (CakeLayer layer : foundLayers){
	    	layer.setCake(cake);
	    	layerBean.save(layer);
	    }
	}

	@Override
	public List<CakeInfo> getAllCakes() {
		CakeDao cakeBean = context.getBean(CakeDao.class);
		List<CakeInfo> result = new ArrayList<>();
	    Iterator<Cake> iterator = cakeBean.findAll().iterator();
	    while (iterator.hasNext()) {
	      Cake cake = iterator.next();
	      CakeToppingInfo cakeToppingInfo =
	          new CakeToppingInfo(cake.getTopping().getId(), cake.getTopping().getName(), 
	        		  cake.getTopping().getCalories());
	      ArrayList<CakeLayerInfo> cakeLayerInfos = new ArrayList<>();
	      for (CakeLayer layer : cake.getLayers()){
	    	  cakeLayerInfos.add(new CakeLayerInfo(layer.getId(), layer.getName(), layer.getCalories()));
	      }
	      CakeInfo cakeInfo = new CakeInfo(cake.getId(), cakeToppingInfo, cakeLayerInfos);
	      result.add(cakeInfo);
	    }
	    return result;
	}

	@Override
	public void saveNewTopping(CakeToppingInfo toppingInfo) {
		CakeToppingDao bean = context.getBean(CakeLayerDao.clas);
		bean.save(new CakeTopping(toppingInfo.name, toppingInfo.calories));
	}

	@Override
	public List<CakeToppingInfo> getAvailableToppings() {
		CakeToppingDao bean = context.getBean(CakeToppingDao.class);
		List<CakeToppingInfo> result = new ArrayList<>();
		Iterator<CakeTopping> iterator = bean.findAll().iterator();
		while (iterator.hasNext()){
			CakeTopping next = iterator.next();
			if (next.getCake() == null){
				result.add(new CakeToppingInfo(next.getId(), next.getName(), next.getCalories()));
			}
		}
		return result;
	}

	@Override
	public void saveNewLayer(CakeLayerInfo layerInfo) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public List<CakeLayerInfo> getAvailableLayers() {
		// TODO Auto-generated method stub
		return null;
	}

}
