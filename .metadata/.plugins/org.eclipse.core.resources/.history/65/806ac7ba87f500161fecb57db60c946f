package com.letattung.reactor.framework;

import java.io.IOException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Iterator;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NioReactor {

	private static final Logger LOGGER = LoggerFactory.getLogger(NioReactor.class);
	
	private final Selector selector;
	private final Dispatcher dispatcher;
	
	private final Queue<Runnable> pendingCommands = new ConcurrentLinkedQueue<>();
	private final ExecutorService reactorMain = Executors.newSingleThreadExecutor();
	
	public NioReactor(Dispatcher dispatcher) throws IOException {
		this.dispatcher = dispatcher;
		this.selector = Selector.open();
	}
	
	public void start() throws IOException{
		reactorMain.execute(() -> {
		      try {
		          LOGGER.info("Reactor started, waiting for events...");
		          eventLoop();
		        } catch (IOException e) {
		          e.printStackTrace();
		        }
		      });
	}
	
	public void stop() throws IOException, InterruptedException{
		reactorMain.shutdownNow();
		selector.wakeup();
		reactorMain.awaitTermination(4, TimeUnit.SECONDS);
		selector.close();
	}
	
	public NioReactor registerChannel(AbstractNioChannel channel) throws IOException{
		SelectionKey key = channel.getJavaChannel().register(selector, channel.getInterestedOps());
		key.attach(channel);
		channel.setReactor(this);
		return this;
	}
	
	private void eventLoop() throws IOException{
		
	}
	
	private void processPendingCommands(){
		Iterator<Runnable> iterator = pendingCommands.iterator();
		while (iterator.hasNext()){
			Runnable command = iterator.next();
			command.run();
			iterator.remove();
		}
	}
	
	private void processKey(SelectionKey key)throws IOException{
		if (key.isAcceptable()){
		  onChannelAcceptable(key);
	    } else if (key.isReadable()) {
	      onChannelReadable(key);
	    } else if (key.isWritable()) {
	      onChannelWritable(key);
		}
	}
	
	private static void onChannelWritable(SelectionKey key) throws IOException{
		AbstractNioChannel channel = (AbstractNioChannel)key.attachment();
		channel.flush(key);
	}
	
	private void onChannelReadable(SelectionKey key){
		try{
			Object readObject = ((AbstractNioChannel)key.attachment()).read();
			dispatchReadEvent(key, readObject);
		}catch(IOException e){
			try{
				key.channel().close();
			}catch (IOException e1){
				e1.printStackTrace();
			}
		}
	}
	
	private void dispatchReadEvent(SelectionKey key, Object readObject){
		dispatcher.onChannelReadEvent((AbstractNioChannel) key.attachment(), readObject, key);
	}
}
